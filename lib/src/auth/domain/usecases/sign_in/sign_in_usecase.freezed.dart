// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'sign_in_usecase.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SignInState {
  SignInAction get action => throw _privateConstructorUsedError;
  SignInFlow get flow => throw _privateConstructorUsedError;
  SignInForm get signInForm => throw _privateConstructorUsedError;
  RequestStatus<dynamic> get sendCodeRequestStatus =>
      throw _privateConstructorUsedError;
  RequestStatus<dynamic> get signInRequestStatus =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SignInStateCopyWith<SignInState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignInStateCopyWith<$Res> {
  factory $SignInStateCopyWith(
          SignInState value, $Res Function(SignInState) then) =
      _$SignInStateCopyWithImpl<$Res>;
  $Res call(
      {SignInAction action,
      SignInFlow flow,
      SignInForm signInForm,
      RequestStatus<dynamic> sendCodeRequestStatus,
      RequestStatus<dynamic> signInRequestStatus});

  $SignInActionCopyWith<$Res> get action;
  $SignInFlowCopyWith<$Res> get flow;
  $SignInFormCopyWith<$Res> get signInForm;
  $RequestStatusCopyWith<dynamic, $Res> get sendCodeRequestStatus;
  $RequestStatusCopyWith<dynamic, $Res> get signInRequestStatus;
}

/// @nodoc
class _$SignInStateCopyWithImpl<$Res> implements $SignInStateCopyWith<$Res> {
  _$SignInStateCopyWithImpl(this._value, this._then);

  final SignInState _value;
  // ignore: unused_field
  final $Res Function(SignInState) _then;

  @override
  $Res call({
    Object? action = freezed,
    Object? flow = freezed,
    Object? signInForm = freezed,
    Object? sendCodeRequestStatus = freezed,
    Object? signInRequestStatus = freezed,
  }) {
    return _then(_value.copyWith(
      action: action == freezed
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as SignInAction,
      flow: flow == freezed
          ? _value.flow
          : flow // ignore: cast_nullable_to_non_nullable
              as SignInFlow,
      signInForm: signInForm == freezed
          ? _value.signInForm
          : signInForm // ignore: cast_nullable_to_non_nullable
              as SignInForm,
      sendCodeRequestStatus: sendCodeRequestStatus == freezed
          ? _value.sendCodeRequestStatus
          : sendCodeRequestStatus // ignore: cast_nullable_to_non_nullable
              as RequestStatus<dynamic>,
      signInRequestStatus: signInRequestStatus == freezed
          ? _value.signInRequestStatus
          : signInRequestStatus // ignore: cast_nullable_to_non_nullable
              as RequestStatus<dynamic>,
    ));
  }

  @override
  $SignInActionCopyWith<$Res> get action {
    return $SignInActionCopyWith<$Res>(_value.action, (value) {
      return _then(_value.copyWith(action: value));
    });
  }

  @override
  $SignInFlowCopyWith<$Res> get flow {
    return $SignInFlowCopyWith<$Res>(_value.flow, (value) {
      return _then(_value.copyWith(flow: value));
    });
  }

  @override
  $SignInFormCopyWith<$Res> get signInForm {
    return $SignInFormCopyWith<$Res>(_value.signInForm, (value) {
      return _then(_value.copyWith(signInForm: value));
    });
  }

  @override
  $RequestStatusCopyWith<dynamic, $Res> get sendCodeRequestStatus {
    return $RequestStatusCopyWith<dynamic, $Res>(_value.sendCodeRequestStatus,
        (value) {
      return _then(_value.copyWith(sendCodeRequestStatus: value));
    });
  }

  @override
  $RequestStatusCopyWith<dynamic, $Res> get signInRequestStatus {
    return $RequestStatusCopyWith<dynamic, $Res>(_value.signInRequestStatus,
        (value) {
      return _then(_value.copyWith(signInRequestStatus: value));
    });
  }
}

/// @nodoc
abstract class _$SignInStateCopyWith<$Res>
    implements $SignInStateCopyWith<$Res> {
  factory _$SignInStateCopyWith(
          _SignInState value, $Res Function(_SignInState) then) =
      __$SignInStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {SignInAction action,
      SignInFlow flow,
      SignInForm signInForm,
      RequestStatus<dynamic> sendCodeRequestStatus,
      RequestStatus<dynamic> signInRequestStatus});

  @override
  $SignInActionCopyWith<$Res> get action;
  @override
  $SignInFlowCopyWith<$Res> get flow;
  @override
  $SignInFormCopyWith<$Res> get signInForm;
  @override
  $RequestStatusCopyWith<dynamic, $Res> get sendCodeRequestStatus;
  @override
  $RequestStatusCopyWith<dynamic, $Res> get signInRequestStatus;
}

/// @nodoc
class __$SignInStateCopyWithImpl<$Res> extends _$SignInStateCopyWithImpl<$Res>
    implements _$SignInStateCopyWith<$Res> {
  __$SignInStateCopyWithImpl(
      _SignInState _value, $Res Function(_SignInState) _then)
      : super(_value, (v) => _then(v as _SignInState));

  @override
  _SignInState get _value => super._value as _SignInState;

  @override
  $Res call({
    Object? action = freezed,
    Object? flow = freezed,
    Object? signInForm = freezed,
    Object? sendCodeRequestStatus = freezed,
    Object? signInRequestStatus = freezed,
  }) {
    return _then(_SignInState(
      action: action == freezed
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as SignInAction,
      flow: flow == freezed
          ? _value.flow
          : flow // ignore: cast_nullable_to_non_nullable
              as SignInFlow,
      signInForm: signInForm == freezed
          ? _value.signInForm
          : signInForm // ignore: cast_nullable_to_non_nullable
              as SignInForm,
      sendCodeRequestStatus: sendCodeRequestStatus == freezed
          ? _value.sendCodeRequestStatus
          : sendCodeRequestStatus // ignore: cast_nullable_to_non_nullable
              as RequestStatus<dynamic>,
      signInRequestStatus: signInRequestStatus == freezed
          ? _value.signInRequestStatus
          : signInRequestStatus // ignore: cast_nullable_to_non_nullable
              as RequestStatus<dynamic>,
    ));
  }
}

/// @nodoc

class _$_SignInState extends _SignInState {
  const _$_SignInState(
      {required this.action,
      required this.flow,
      required this.signInForm,
      required this.sendCodeRequestStatus,
      required this.signInRequestStatus})
      : super._();

  @override
  final SignInAction action;
  @override
  final SignInFlow flow;
  @override
  final SignInForm signInForm;
  @override
  final RequestStatus<dynamic> sendCodeRequestStatus;
  @override
  final RequestStatus<dynamic> signInRequestStatus;

  @override
  String toString() {
    return 'SignInState(action: $action, flow: $flow, signInForm: $signInForm, sendCodeRequestStatus: $sendCodeRequestStatus, signInRequestStatus: $signInRequestStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SignInState &&
            const DeepCollectionEquality().equals(other.action, action) &&
            const DeepCollectionEquality().equals(other.flow, flow) &&
            const DeepCollectionEquality()
                .equals(other.signInForm, signInForm) &&
            const DeepCollectionEquality()
                .equals(other.sendCodeRequestStatus, sendCodeRequestStatus) &&
            const DeepCollectionEquality()
                .equals(other.signInRequestStatus, signInRequestStatus));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(action),
      const DeepCollectionEquality().hash(flow),
      const DeepCollectionEquality().hash(signInForm),
      const DeepCollectionEquality().hash(sendCodeRequestStatus),
      const DeepCollectionEquality().hash(signInRequestStatus));

  @JsonKey(ignore: true)
  @override
  _$SignInStateCopyWith<_SignInState> get copyWith =>
      __$SignInStateCopyWithImpl<_SignInState>(this, _$identity);
}

abstract class _SignInState extends SignInState {
  const factory _SignInState(
          {required final SignInAction action,
          required final SignInFlow flow,
          required final SignInForm signInForm,
          required final RequestStatus<dynamic> sendCodeRequestStatus,
          required final RequestStatus<dynamic> signInRequestStatus}) =
      _$_SignInState;
  const _SignInState._() : super._();

  @override
  SignInAction get action => throw _privateConstructorUsedError;
  @override
  SignInFlow get flow => throw _privateConstructorUsedError;
  @override
  SignInForm get signInForm => throw _privateConstructorUsedError;
  @override
  RequestStatus<dynamic> get sendCodeRequestStatus =>
      throw _privateConstructorUsedError;
  @override
  RequestStatus<dynamic> get signInRequestStatus =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SignInStateCopyWith<_SignInState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SignInFlow {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() email,
    required TResult Function() password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Email value) email,
    required TResult Function(Password value) password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignInFlowCopyWith<$Res> {
  factory $SignInFlowCopyWith(
          SignInFlow value, $Res Function(SignInFlow) then) =
      _$SignInFlowCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignInFlowCopyWithImpl<$Res> implements $SignInFlowCopyWith<$Res> {
  _$SignInFlowCopyWithImpl(this._value, this._then);

  final SignInFlow _value;
  // ignore: unused_field
  final $Res Function(SignInFlow) _then;
}

/// @nodoc
abstract class $EmailCopyWith<$Res> {
  factory $EmailCopyWith(Email value, $Res Function(Email) then) =
      _$EmailCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmailCopyWithImpl<$Res> extends _$SignInFlowCopyWithImpl<$Res>
    implements $EmailCopyWith<$Res> {
  _$EmailCopyWithImpl(Email _value, $Res Function(Email) _then)
      : super(_value, (v) => _then(v as Email));

  @override
  Email get _value => super._value as Email;
}

/// @nodoc

class _$Email implements Email {
  const _$Email();

  @override
  String toString() {
    return 'SignInFlow.email()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Email);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() email,
    required TResult Function() password,
  }) {
    return email();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
  }) {
    return email?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Email value) email,
    required TResult Function(Password value) password,
  }) {
    return email(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
  }) {
    return email?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email(this);
    }
    return orElse();
  }
}

abstract class Email implements SignInFlow {
  const factory Email() = _$Email;
}

/// @nodoc
abstract class $PasswordCopyWith<$Res> {
  factory $PasswordCopyWith(Password value, $Res Function(Password) then) =
      _$PasswordCopyWithImpl<$Res>;
}

/// @nodoc
class _$PasswordCopyWithImpl<$Res> extends _$SignInFlowCopyWithImpl<$Res>
    implements $PasswordCopyWith<$Res> {
  _$PasswordCopyWithImpl(Password _value, $Res Function(Password) _then)
      : super(_value, (v) => _then(v as Password));

  @override
  Password get _value => super._value as Password;
}

/// @nodoc

class _$Password implements Password {
  const _$Password();

  @override
  String toString() {
    return 'SignInFlow.password()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Password);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() email,
    required TResult Function() password,
  }) {
    return password();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
  }) {
    return password?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? email,
    TResult Function()? password,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Email value) email,
    required TResult Function(Password value) password,
  }) {
    return password(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
  }) {
    return password?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Email value)? email,
    TResult Function(Password value)? password,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password(this);
    }
    return orElse();
  }
}

abstract class Password implements SignInFlow {
  const factory Password() = _$Password;
}

/// @nodoc
mixin _$SignInAction {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() popFlow,
    required TResult Function() goToHome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Idle value) idle,
    required TResult Function(PopFlow value) popFlow,
    required TResult Function(GoToHome value) goToHome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignInActionCopyWith<$Res> {
  factory $SignInActionCopyWith(
          SignInAction value, $Res Function(SignInAction) then) =
      _$SignInActionCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignInActionCopyWithImpl<$Res> implements $SignInActionCopyWith<$Res> {
  _$SignInActionCopyWithImpl(this._value, this._then);

  final SignInAction _value;
  // ignore: unused_field
  final $Res Function(SignInAction) _then;
}

/// @nodoc
abstract class _$IdleCopyWith<$Res> {
  factory _$IdleCopyWith(_Idle value, $Res Function(_Idle) then) =
      __$IdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$IdleCopyWithImpl<$Res> extends _$SignInActionCopyWithImpl<$Res>
    implements _$IdleCopyWith<$Res> {
  __$IdleCopyWithImpl(_Idle _value, $Res Function(_Idle) _then)
      : super(_value, (v) => _then(v as _Idle));

  @override
  _Idle get _value => super._value as _Idle;
}

/// @nodoc

class _$_Idle implements _Idle {
  const _$_Idle();

  @override
  String toString() {
    return 'SignInAction.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Idle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() popFlow,
    required TResult Function() goToHome,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Idle value) idle,
    required TResult Function(PopFlow value) popFlow,
    required TResult Function(GoToHome value) goToHome,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _Idle implements SignInAction {
  const factory _Idle() = _$_Idle;
}

/// @nodoc
abstract class $PopFlowCopyWith<$Res> {
  factory $PopFlowCopyWith(PopFlow value, $Res Function(PopFlow) then) =
      _$PopFlowCopyWithImpl<$Res>;
}

/// @nodoc
class _$PopFlowCopyWithImpl<$Res> extends _$SignInActionCopyWithImpl<$Res>
    implements $PopFlowCopyWith<$Res> {
  _$PopFlowCopyWithImpl(PopFlow _value, $Res Function(PopFlow) _then)
      : super(_value, (v) => _then(v as PopFlow));

  @override
  PopFlow get _value => super._value as PopFlow;
}

/// @nodoc

class _$PopFlow implements PopFlow {
  const _$PopFlow();

  @override
  String toString() {
    return 'SignInAction.popFlow()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PopFlow);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() popFlow,
    required TResult Function() goToHome,
  }) {
    return popFlow();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
  }) {
    return popFlow?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
    required TResult orElse(),
  }) {
    if (popFlow != null) {
      return popFlow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Idle value) idle,
    required TResult Function(PopFlow value) popFlow,
    required TResult Function(GoToHome value) goToHome,
  }) {
    return popFlow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
  }) {
    return popFlow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
    required TResult orElse(),
  }) {
    if (popFlow != null) {
      return popFlow(this);
    }
    return orElse();
  }
}

abstract class PopFlow implements SignInAction {
  const factory PopFlow() = _$PopFlow;
}

/// @nodoc
abstract class $GoToHomeCopyWith<$Res> {
  factory $GoToHomeCopyWith(GoToHome value, $Res Function(GoToHome) then) =
      _$GoToHomeCopyWithImpl<$Res>;
}

/// @nodoc
class _$GoToHomeCopyWithImpl<$Res> extends _$SignInActionCopyWithImpl<$Res>
    implements $GoToHomeCopyWith<$Res> {
  _$GoToHomeCopyWithImpl(GoToHome _value, $Res Function(GoToHome) _then)
      : super(_value, (v) => _then(v as GoToHome));

  @override
  GoToHome get _value => super._value as GoToHome;
}

/// @nodoc

class _$GoToHome implements GoToHome {
  const _$GoToHome();

  @override
  String toString() {
    return 'SignInAction.goToHome()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is GoToHome);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() popFlow,
    required TResult Function() goToHome,
  }) {
    return goToHome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
  }) {
    return goToHome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? popFlow,
    TResult Function()? goToHome,
    required TResult orElse(),
  }) {
    if (goToHome != null) {
      return goToHome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Idle value) idle,
    required TResult Function(PopFlow value) popFlow,
    required TResult Function(GoToHome value) goToHome,
  }) {
    return goToHome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
  }) {
    return goToHome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Idle value)? idle,
    TResult Function(PopFlow value)? popFlow,
    TResult Function(GoToHome value)? goToHome,
    required TResult orElse(),
  }) {
    if (goToHome != null) {
      return goToHome(this);
    }
    return orElse();
  }
}

abstract class GoToHome implements SignInAction {
  const factory GoToHome() = _$GoToHome;
}
